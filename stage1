#!/bin/bash -x
#
# This script is the first stage in bootstrapping a Fedora build to a
# new platform or architecture.  Running with no arguments builds a
# cross-development environment, then cross-builds a minimal rootfs.
# Once you have this minimal rootfs booted, run stage2 in that rootfs
# to build the rest of the bootstrap packages.
#
# This script assumes that all the needed SRPMs are available in
# $SRPMDIR (below) and that there is exactly one rev of each package's
# SRPM.  The resulting rootfs will be build in $ROOTFS (below).
#
# This script depends on the following packages being available on the host:
#	automake autoconf libtool make patch gcc gcc-c++ bison flex
#	gmp-devel mpfr-devel libmpc-devel rsync gettext-devel tcl
#
# Note that SRPMDIR_LOCAL is for local SRPMs that override the
# official ones, for example, board-specific kernel RPMs.
#
# You may pass a single module name on the command line to rebuild
# just that one module.  Module names match the big case statement
# below.
#
# For reference, when a package is built multiple times...
#
# foo-host is the "runs on host" part of a standard cross-compiler
# foo-target is the target libraries etc
# target-foo is a cross-built target-native
#
# Note that the "dev" step requires sudo, as it installs special files
# in $ROOTFS/dev/
#
# Overall instructions for building stages 1-3 are:
#	# Build stage1.
#	Run "./stage1" in the build host.
#
#	# Copy $ROOTFS to the box that will run the chroot in stage2.
#
#	# In the box that will run the chroot do:
#	$ chroot /path/to/chroot /bin/bash
#
#	Note: If inside the chroot, you cannot do "ps", you will
#	need to go outside of the chroot and:
#		mount -o bind /proc /path/to/chroot/proc
#		mount -o bind /sys /path/to/chroot/sys
#	FIXME: ^^^^^ This could be determined programatically from within
#		the chroot, and at least dump out an error if ps doesn't
#		work.
#	FIXME: Check the sanity of the chroot programatically
#		(presence of /proc, /sys, SRPMS, noarch RPMS, etc
#
#	# Build stage2 within the chroot.
#       $ cd /stage2
#	# Update -j1 to whatever is appropriate in local.conf.
#	$ ./stage2
#
#	# Prepare environment for building stage3.
#	Run "./stage1 stage3" in the build host.
#	Copy host:$ROOTFS/stage3 to chroot:/
#	Copy host:SRPMs to chroot:/SRPMS
#	Copy [noarch-RPMS] to chroot:/RPMS-noarch/

#	# Build stage3 in the chroot.
#	$ cd /stage3
#	# Update -j1 to whatever is appropriate in local.conf.
#	$ ./stage3"
#
# ------------------------------------------------------------

### Architecture dependent configury

# TARGET: The cross-compiler target.
TARGET=aarch64-redhat-linux-gnu

# KARCH: Used by the kernel and glibc.

# KERNEL_RPMTARGET: Due to naming politics, the kernel may have a
# different target than $TARGET.

# RPMTARGET: RPMBUILD target for prepping sources.

# SUFFIX: Default library path.

# EGLIBC_ARCH: ARCH variable for eglibc.

# CONFIG_EXTRA: Additional parameters to pass to ./configure.

# GCC_CONFIG_EXTRA: Additional parameters to pass to GCC's ./configure.

# BUSYBOX_DEFCONFIG: config file to use for busybox

case $TARGET in
    aarch64-*)
	KCONFIG=kernel-3.*-arm64.config
	KARCH=arm64
	KERNEL_RPMTARGET=$TARGET
	RPMTARGET=$TARGET
	SUFFIX=64
	CONFIG_EXTRA="--with-arch=armv8
                      --with-fpu=neon-fp-armv8"
	GCC_CONFIG_EXTRA="--with-arch=armv8-a"
	EGLIBC_ARCH=arm
	BUSYBOX_DEFCONFIG=defconfig
	;;
    ppc64le-*)
	KCONFIG=kernel-3.*-ppc64le.config
	KARCH=powerpc
	RPMTARGET=$TARGET
	KERNEL_RPMTARGET=$TARGET
	SUFFIX=64
	CONFIG_EXTRA=""
	GCC_CONFIG_EXTRA="--disable-multilib"
	EGLIBC_ARCH=ppc
	BUSYBOX_DEFCONFIG=defconfig
	;;
    *)
	echo "Unsupported TARGET=$TARGET".
	exit 1
	;;
esac

### Directory and miscelaneous configury

TOP=$PWD
MYDIR=${0%/*}
STAGE2=$MYDIR/stage2
STAGE3=$MYDIR/stage3

SRPMDIR=$TOP/SRPMs
SRPMDIR_LOCAL=$TOP/SRPMlocal
if [ -x /usr/bin/nproc ]; then
    J=-j$(nproc)
else
    J=-j1
fi
# default port for native builds is 3632, don't use that
DISTCC_PORT=3639

BUILDDIR=$TOP/builds
PREFIX=$TOP/install
KCONFIGDIR=$BUILDDIR/kernel
KIMAGE=uImage
NEED_XLOADER=no
NEED_UBOOT=no

# this is where the new rootfs will be built
ROOTFS=$TOP/rootfs

if [ -f $MYDIR/local.conf ]
then
    . $MYDIR/local.conf
fi

# ------------------------------------------------------------
# Sanity checks

error()
{
    echo Error: "$@" 1>&2
    ERROR=1
}

if [ ! -d $SRPMDIR/. ]
then
    error SRPMDIR set to $SRPMDIR, but I see no directory there
    echo '$'SRPMDIR usually refers to a symlink to a directory with all the '*'.src.rpm files in it.
    echo SRPMDIR_LOCAL may likewise refer to a directory with local srpm overrides in it
fi

test x"$ERROR" = x"1" && exit 1

unset CC
unset CXX
unset CFLAGS
unset CXXFLAGS
unset AR
unset LD
unset AS

if [ -f /usr/local/include/ppl_c.h ]
then
    WITHPPL="--with-ppl=/usr/local"
else
    WITHPPL=""
fi

# ------------------------------------------------------------

echo
echo Running: $0 $*
echo Date: `date`
echo Cwd: `pwd`
echo

SRCTOP=$TOP/rpmbuild
SRC=$SRCTOP/BUILD
SPECS=$SRCTOP/SPECS

mkdirp()
{
    test -d $1 || mkdir -p $1
}

mkdirp $SRC
mkdirp $ROOTFS
mkdirp $PREFIX
mkdirp $BUILDDIR
mkdirp $TOP/done

export PATH=$PREFIX/bin:$PATH

mcd()
{
    test -d $1 || mkdir -p $1
    cd $1
}

srpm()
{
    STOP=${2-$TOP}
    STARGET=${3-$RPMTARGET}
    SDIR=$SRPMDIR_LOCAL
    SRPM=$(cd $SDIR; \ls -1 $1-*.src.rpm 2>/dev/null | egrep -v $1'-.*-.*-' | tail -1)
    if [ -f $SDIR/$SRPM ]
    then true; else
	SDIR=$SRPMDIR
	SRPM=$(cd $SDIR; \ls -1 $1-*.src.rpm 2>/dev/null | tail -1)
	SRPM=$(cd $SDIR; \ls -1 $1-*.src.rpm 2>/dev/null | egrep -v $1'-.*-.*-' | tail -1)
    fi
    echo SRPM is $SRPM
    SPEC=${SRPM%-*}
    SPEC=${SPEC%-*}
    if [ -f $STOP/rpmbuild/SPECS/$SPEC.spec ];
    then true; else
	test -f $SDIR/$SRPM || exit 1
	HOME=$STOP rpm -i $SDIR/$SRPM
	cd $STOP/rpmbuild/SPECS

	HOME=$STOP rpmbuild --target=$STARGET --nodeps -bp $SPEC.spec

	# Fix libtool.m4 and associated configure files if appropriate.
	#
	# FIXME: A better alternative would be to only look in
	# $SRC/$1-*, but for some packages $1 == libmpc, whereas the
	# directory is mpc.  We could duplicate this code for each package
	# right before its ./configure, but that's tedious.
	#
	# If the `find' in the script below takes too long, perhaps it's
	# time to rethink this.
	(cd $STOP && $TOP/libtool-handle-ppc64le.sh)

	cd $TOP
    fi
}
rsrpm()
{
    srpm $1 $ROOTFS/stage2
}

set -e

BUILD=`gcc -v 2>&1 | grep Target: | sed 's/.*: //'`

# These are for cross-tools like binutils
CONFIGARGS="--prefix=$PREFIX
            --libdir=$PREFIX/lib${SUFFIX}
	    --target=$TARGET
	    ${CONFIG_EXTRA}
	    --enable-languages=c,c++
	    --with-sysroot=$ROOTFS
	    --enable-threads=posix
	    --enable-64-bit-bfd
	    $WITHPPL
"

TCONFIGARGS="--prefix=/usr
             --libdir=/usr/lib${SUFFIX}
	     --with-sysroot=/
	     --with-build-sysroot=$ROOTFS
	     --build=$BUILD
	     --host=$TARGET
	     --target=$TARGET
	     --enable-werror=no
	     --enable-cxx
	     ${CONFIG_EXTRA}
	     --enable-languages=c,c++
	     --enable-threads=posix
	     --without-guile
"

# These are for gcc cross-tools (politics sometime result in slightly
# different arch names)
GCC_CONFIGARGS="--prefix=$PREFIX
            --libdir=$PREFIX/lib${SUFFIX}
	    --target=$TARGET
	    ${GCC_CONFIG_EXTRA}
	    --enable-languages=c,c++
	    --with-sysroot=$ROOTFS
	    --enable-threads=posix
	    --enable-64-bit-bfd
	    $WITHPPL
"

GCC_TCONFIGARGS="--prefix=/usr
             --libdir=/usr/lib${SUFFIX}
	     --with-sysroot=/
	     --with-build-sysroot=$ROOTFS
	     --build=$BUILD
	     --host=$TARGET
	     --target=$TARGET
	     --enable-werror=no
	     --enable-cxx
	     ${GCC_CONFIG_EXTRA}
	     --enable-languages=c,c++
	     --enable-threads=posix
"

KERNELARGS="ARCH=${KARCH} CROSS_COMPILE=${TARGET}-"


# Must use install_root=$ROOTFS on all makes

prefill_gcc_cache()
{
    echo 'lt_cv_shlibpath_overrides_runpath=no' > config.cache
    echo 'gcc_cv_libc_provides_ssp=yes' >> config.cache
}

setup_glibc()
{
    # This path MUST be relative, not absolute
    GV=$(cd $SRC; echo glibc-2*)
    GLIBCARGS="--prefix=/usr
	--with-headers=$ROOTFS/usr/include
	--enable-kernel=2.6.32
	--enable-bind-now
	--build $BUILD
	--host $TARGET
	--disable-profile
	--cache-file=config.cache
	--without-cvs
	--with-elf
	--without-gd
	--disable-sanity-checks
	--with-tls
	--with-__thread
	--enable-obsolete-rpc
	"
}

prefill_glibc_cache()
{
    echo libc_cv_forced_unwind=yes > config.cache
    echo libc_cv_c_cleanup=yes >> config.cache
    echo libc_cv_ctors_header=yes >> config.cache
    echo ac_cv_header_cpuid_h=yes >> config.cache
    echo libc_cv_gcc_builtin_expect=yes >> config.cache
}

setup_eglibc()
{
    # This path MUST be relative, not absolute
    GLIBCPORTSSRC=../$(cd $SRC/eglibc-*; echo ports*)
    #GLIBCPORTSSRC=ports

    GV=$(cd $SRC; echo eglibc-*/libc)
    EGLIBCARGS0="--prefix=/usr
        --libdir=/usr/lib${SUFFIX}
        --includedir=/usr/include
	--with-headers=$ROOTFS/usr/include
	--enable-kernel=2.6.32
	--enable-bind-now
	--build $BUILD
	--host $TARGET
	--disable-profile
	--cache-file=config.cache
	--without-cvs
	--with-elf
	--without-gd"
    EGLIBCARGS1="$EGLIBCARGS0
	--enable-add-ons=$GLIBCPORTSSRC,nptl
	--disable-sanity-checks
	--with-tls
	--with-__thread
	"
    EGLIBCARGS2="$EGLIBCARGS0
	--enable-add-ons=$GLIBCPORTSSRC,nptl
	--disable-sanity-checks
	--with-tls
	--with-__thread
	"
}

prefill_eglibc_cache()
{
    echo libc_cv_forced_unwind=yes > config.cache
    echo libc_cv_c_cleanup=yes >> config.cache
    echo libc_cv_ctors_header=yes >> config.cache
    echo libc_cv_ssp=yes >> config.cache
    echo libc_cv_gcc_builtin_expect=yes >> config.cache
}

notparallel()
{
    echo .NOTPARALLEL: >> Makefile
}

fix_la()
{
    for la in $ROOTFS/usr/lib${SUFFIX}/*$1*.la
    do
	if test -f $la
	then
	    rm $la
	fi
    done
}

#--------------------------------------------------

go()
{
    test -f $TOP/done/$1 && return 0
    if "$0" "$@"
    then
	date > $TOP/done/$1
    else
	echo
	echo Module "$@" failed
	return 1
    fi
}

case "$1" in
    "" )
	go usrlinks
	go kernel-headers
	go binutils
	go gcc-host
	go glibc-headers
	go gcc-libgcc
	go glibc
	go gcc
	go dev

#       go kernel
	test x"$NEED_XLOADER" == x"yes" && go x-loader
	test x"$NEED_UBOOT" == x"yes" && go u-boot

	go gmp
	go mpfr
	go mpc

	go libsepol
	go zlib

	go t-binutils
	go t-gcc
	go make
	go sed
	go coreutils
	go busybox
	# Bash must come after busybox so the `sh' symbolic link is bash,
	# not busybox.
	go bash
	go util-linux
	go tar
	go gzip
	go bzip2
	go diffutils
	go xz
	go pcre
	go libselinux
	go findutils
	go gawk
	go patch
	go unzip
	go which
	go grep
#	go distcc
#	go ccache

	# After the stage2 environment is built here...
	go stage2
	# ...we're done.  The rest of stage2 must be built in a
	# chroot.  When stage2 packages are built in said chroot, the
	# stage3 environment can be generated.
	exit 0

	go stage3

	;;

    "clean" )
	set -vx
	mkdir .quickrm.$$
	mv -f $SRCTOP $ROOTFS $PREFIX $BUILDDIR $TOP/done .quickrm.$$
	rm -rf .quickrm.$$ &
	;;

    "sync" )
#	echo Copying built rootfs to panda-1...
#	rsync -a $ROOTFS/ root@panda-1:/hardfp/
	;;

    "test1" )
	echo test running
	go test
	echo test passed
	;;

    "test" )
	echo Testing
	exit 1
	;;

#--------------------------------------------------
# host cross-tools

    "kernel-headers" )
	srpm kernel $TOP $KERNEL_RPMTARGET
	mcd $BUILDDIR/kernel
	cd $SRC/kernel-*/linux-*
	if [ ! -x $TARGET-gcc ]; then
	    # The first time around, we won't have a cross compiler.
	    # I hope this is ok ;-).
	    C=gcc
	else
	    C=$TARGET-gcc
	fi
	make CC=$C $KERNELARGS INSTALL_HDR_PATH=$ROOTFS/usr headers_install
	;;

    "binutils" )
	srpm binutils
	mcd $BUILDDIR/binutils
	$SRC/binutils-*/configure $CONFIGARGS
	notparallel
	make $J
	make $J install
	;;

    "gcc-host" )
	srpm gcc
	mcd $BUILDDIR/gcc
	prefill_gcc_cache
	$SRC/gcc-*/configure $GCC_CONFIGARGS --with-headers=$ROOTFS/usr/include --cache-file=config.cache
	notparallel

	# Pass gcc_cv_libc_provides_ssp down, because the config.cache
	# version is not passed down to the gcc subdir.
	make $J all-host gcc_cv_libc_provides_ssp=yes
	make $J install-host gcc_cv_libc_provides_ssp=yes


if false; then
	mkdirp $ROOTFS/usr/lib${SUFFIX}
	for o in crt Scrt1 crti crtbegin crtbeginS crtend crtendS crtn
	do
	  $TARGET-gcc -nostdlib -nostartfiles -c -x c /dev/null -c -o $ROOTFS/usr/lib${SUFFIX}/$o.o
	done
	for so in gcc gcc_s c
	do
	  $TARGET-gcc -nostdlib -nostartfiles -shared -x c /dev/null -o $ROOTFS/usr/lib${SUFFIX}/lib$so.so
	done
fi
	;;

    "glibc-headers" )
	set -vx
	srpm glibc
	setup_glibc
	mcd $BUILDDIR/glibc-stage1
	prefill_glibc_cache 
	$SRC/$GV/configure $GLIBCARGS
	notparallel
	make $J ARCH=${KARCH} cross-compiling=yes install-headers install_root=$ROOTFS
	touch $ROOTFS/usr/include/gnu/stubs.h
	touch $ROOTFS/usr/include/bits/stdio_lim.h

	( cd $ROOTFS/usr/include/bits
	  sed '/ifndef.*NO_LONG_DOUBLE/,/#endif/d' < mathdef.h > mathdef.h.new
	  mv mathdef.h.new mathdef.h
	)
	

	# We also build just enough files to link libgcc.so.  The fake
	# libc.so will never actually get used.
	mkdirp $ROOTFS/usr/lib${SUFFIX}
	make $J ARCH=${KARCH} cross-compiling=yes csu/subdir_lib
#	cp csu/crt*.o $ROOTFS/usr/lib${SUFFIX}
	for C in `cd csu; echo crt*.o`; do
	    echo "" | $TARGET-as -o $ROOTFS/usr/lib${SUFFIX}/$C
	 done
	$TARGET-gcc -nostdlib -nostartfiles -shared -x c /dev/null -o $ROOTFS/usr/lib${SUFFIX}/libc.so

	;;

    "eglibc-headers" )
	set -vx
	srpm eglibc
	setup_eglibc
	mcd $BUILDDIR/eglibc-stage1
	prefill_eglibc_cache 
	$SRC/$GV/configure $EGLIBCARGS1
	notparallel
	make $J ARCH=$EGLIBC_ARCH cross-compiling=yes install-headers install_root=$ROOTFS install-bootstrap-headers=yes
	touch $ROOTFS/usr/include/gnu/stubs.h
	touch $ROOTFS/usr/include/bits/stdio_lim.h
	cp $SRC/$GV/nptl/sysdeps/pthread/pthread.h $ROOTFS/usr/include

	( cd $ROOTFS/usr/include/bits
	  sed '/ifndef.*NO_LONG_DOUBLE/,/#endif/d' < mathdef.h > mathdef.h.new
	  mv mathdef.h.new mathdef.h
	)
	

	# We also build just enough files to link libgcc.so.  The fake
	# libc.so will never actually get used.
	mkdirp $ROOTFS/usr/lib${SUFFIX}
	make $J ARCH=$EGLIBC_ARCH cross-compiling=yes csu/subdir_lib
	cp csu/crt*.o $ROOTFS/usr/lib${SUFFIX}
	cp csu/elf-init*.o $ROOTFS/usr/lib${SUFFIX}
	cp csu/libc-start*.o $ROOTFS/usr/lib${SUFFIX}
	$TARGET-gcc -nostdlib -nostartfiles -shared -x c /dev/null -o $ROOTFS/usr/lib${SUFFIX}/libc.so
	;;

    "gcc-libgcc" )
	srpm gcc
	mcd $BUILDDIR/gcc
	prefill_gcc_cache
	$SRC/gcc-*/configure $GCC_CONFIGARGS --with-headers=$ROOTFS/usr/include --cache-file=config.cache
	notparallel
	# Pass gcc_cv_libc_provides_ssp down, because the config.cache
	# version is not passed down to the gcc subdir.
	make $J all-target-libgcc all-target-libssp gcc_cv_libc_provides_ssp=yes
	make $J install-target-libgcc install-target-libssp gcc_cv_libc_provides_ssp=yes
	;;

    "glibc" )
	srpm glibc
	setup_glibc
	mcd $BUILDDIR/glibc
	prefill_glibc_cache 
	$SRC/$GV/configure $GLIBCARGS
	notparallel
	make $J ARCH=${KARCH} cross-compiling=yes
	make $J ARCH=${KARCH} cross-compiling=yes install install_root=$ROOTFS

	( cd $ROOTFS/usr/include/bits
	  sed '/ifndef.*NO_LONG_DOUBLE/,/#endif/d' < mathdef.h > mathdef.h.new
	  mv mathdef.h.new mathdef.h
	)

	;;

    "eglibc" )
	srpm eglibc
	setup_eglibc
	mcd $BUILDDIR/eglibc
	prefill_eglibc_cache 
	$SRC/$GV/configure $EGLIBCARGS2
	notparallel
	make $J ARCH=$EGLIBC_ARCH cross-compiling=yes
	make $J ARCH=$EGLIBC_ARCH cross-compiling=yes install install_root=$ROOTFS

	( cd $ROOTFS/usr/include/bits
         sed '/ifndef.*NO_LONG_DOUBLE/,/#endif/d' < mathdef.h > mathdef.h.new
         mv mathdef.h.new mathdef.h
       )
       ;;

    "gcc" )
       srpm gcc
       mcd $BUILDDIR/gcc
       prefill_gcc_cache
       $SRC/gcc-*/configure $GCC_CONFIGARGS --with-headers=$ROOTFS/usr/include --cache-file=config.cache
	notparallel
	make $J
	make $J install
	mcd $ROOTFS/lib${SUFFIX}/gcc
	rsync -av $PREFIX/lib${SUFFIX}/gcc/ $ROOTFS/lib${SUFFIX}/gcc/
	rsync -av $PREFIX/$TARGET/lib/ $ROOTFS/lib${SUFFIX}/
	;;

#--------------------------------------------------
# target boot support

    "usrlinks" )
	test -d $ROOTFS || mkdir -p $ROOTFS
	mkdir $ROOTFS/usr
	for i in bin sbin lib${SUFFIX} libexec
	do
	    ln -s usr/$i $ROOTFS/$i
	    mkdir $ROOTFS/usr/$i
	done
        ln -s usr/lib${SUFFIX} $ROOTFS/lib
	for i in etc proc sys
	do
	    mkdir $ROOTFS/$i
	done
	;;

    "dev" )
	rsync -av $TOP/dev-template/ $ROOTFS/

	mcd $ROOTFS/tmp
	chmod 1777 .

	mcd $ROOTFS/dev
	sudo mknod null		c   1 3
	sudo mknod zero		c   1 5
	sudo mknod urandom	c   1 9
	sudo mknod tty		c   5 0
	sudo mknod console	c   5 1
	sudo mknod sda		b   8 0
	sudo mknod sda1		b   8 1
	sudo mknod sda2		b   8 2
	sudo mknod sda3		b   8 3
	sudo mknod sda4		b   8 4
	sudo mknod mmcblk0	b 179 0
	sudo mknod mmcblk0p1	b 179 1
	sudo mknod mmcblk0p2	b 179 2
	sudo mknod mmcblk0p3	b 179 3
	sudo mknod mmcblk0p4	b 179 4
	sudo mknod tty00	c 253 0
	sudo mknod tty01	c 253 1
	sudo mknod tty02	c 253 2
	sudo mknod tty03	c 253 3

	sudo mknod tty2 	c 4 2
	sudo mknod tty3 	c 4 3
	sudo mknod tty4 	c 4 4

	sudo mknod ttyS0	c 4 64
	sudo mknod ttyS1	c 4 65
	sudo mknod ttyS2	c 4 66
	sudo mknod ttyS3	c 4 67
	sudo chmod a+rw null zero
	;;

    "kernel" )
	srpm kernel $TOP $KERNEL_RPMTARGET
	mcd $BUILDDIR/kernel
	echo copying kernel sources to build area...
	rsync -a --delete $SRC/kernel-*/linux-*/ ./
	cp $KCONFIGDIR/$KCONFIG .config
	make $J ARCH=$KARCH CROSS_COMPILE=${TARGET}- silentoldconfig
	#make $J ARCH=$KARCH CROSS_COMPILE=${TARGET}- $KIMAGE
	make $J ARCH=$KARCH CROSS_COMPILE=${TARGET}- 
	make $J ARCH=$KARCH CROSS_COMPILE=${TARGET}- modules
	make $J ARCH=$KARCH CROSS_COMPILE=${TARGET}- INSTALL_MOD_PATH=$ROOTFS modules_install

	mkdirp $ROOTFS/boot
	mkdirp $ROOTFS/lib/firmware
	cp arch/$KARCH/boot/$KIMAGE $ROOTFS/boot
	;;

    "x-loader" )
	if [ ! -f $BUILDDIR/x-loader/README ]
	then
	    cd $BUILDDIR
	    git clone git://gitorious.org/x-loader/x-loader.git
	fi
	cd $BUILDDIR/x-loader
	sed s/-Werror// cpu/omap4/config.mk > cpu/omap4/config.mk.new
	mv cpu/omap4/config.mk.new cpu/omap4/config.mk
	make $J distclean
	make $J CROSS_COMPILE=${TARGET}- omap4430panda_config
	make $J CROSS_COMPILE=${TARGET}-
	mkdirp $ROOTFS/boot
	cp MLO $ROOTFS/boot
	;;

    "u-boot" )
	# git git://git.denx.de/u-boot.git
	if [ ! -f $BUILDDIR/u-boot/README ]
	then
	    cd $BUILDDIR
	    git clone git://git.denx.de/u-boot.git
	fi
	cd $BUILDDIR/u-boot
	make $J distclean
	make $J CROSS_COMPILE=${TARGET}- omap4_panda_config
	make $J CROSS_COMPILE=${TARGET}- u-boot.img
	mkdirp $ROOTFS/boot
	cp u-boot.img $ROOTFS/boot/u-boot.img
	;;

    "djtest" )
	cd $TOP/djtest
	make $J
	make $J install ROOTFS=${ROOTFS}
	;;

#--------------------------------------------------
# target-side libraries

    gmp )
	L=$1
	srpm $L
	mcd $BUILDDIR/t-$L
	$SRC/${L}-*/configure $TCONFIGARGS
	make $J

	# The contents of libdir (which in this case is
	# /usr/lib${SUFFIX}), will get passed to -L in one of the
	# (re)link stages while installing, thus getting libgcc_so.*
	# from the host.
	#
	# ?? I don't understand why --libdir=/usr/lib64 is being
	#    passed in $TCONFIGARGS instead of
	#    --libdir=${ROOTFS}/usr/lib64, but assuming that's the way
	#    it's supposed to to be, then fix libdir here right before
	#    installing the binaries. ??--aldyh
	for i in *.la; do
	    sed -i~ -e "s;libdir='/usr/lib;libdir='$ROOTFS/usr/lib;" $i
	done
	make $J install DESTDIR=${ROOTFS}

	fix_la $L
	;;

    mpfr | ppl )
	L=$1
	srpm $L
	mcd $BUILDDIR/t-$L
	$SRC/${L}-*/configure $TCONFIGARGS
	make $J
	make $J install DESTDIR=${ROOTFS}
	fix_la $L
	;;

    mpc )
	L=$1
	srpm libmpc
	mcd $BUILDDIR/t-$L

	# The MPC_GMP_CC_CFLAGS macro used in the configure.ac below
	# determines what CC/CFLAGS were used to build libgmp*.
	# Unfortunately, it calls the system's GCC (to compile
	# <gmp.h>) in order to determine this.  This will pick up the
	# system's gmp.h, which will consequently return the system
	# compiler.
	#
	# Set CC here to avoid this nonsense.
	CC=$TARGET-gcc $SRC/${L}-*/configure $TCONFIGARGS

	make
	make $J install DESTDIR=${ROOTFS}
	fix_la $L
	;;

    zlib )
	srpm zlib
	mcd $BUILDDIR/t-zlib
	rsync -av $SRC/zlib-*/ ./
        if [ "$SUFFIX" = "64" ]
        then
            ARGS="--libdir=/usr/lib64"
        fi
	CHOST=${TARGET} \
	    prefix=/usr \
	    ./configure $ARGS
	make
	make $J install DESTDIR=${ROOTFS}
	fix_la zlib
	;;

    "cloog" )
	srpm cloog
	mcd $BUILDDIR/t-cloog
	$SRC/cloog-*/configure $TCONFIGARGS --with-ppl
	make $J
	make $J install DESTDIR=${ROOTFS}
	fix_la cloog
	;;

    libsepol )
	srpm libsepol
	mcd $BUILDDIR/t-libsepol
	rsync -av $SRC/libsepol*/ ./
	make $J \
	    CC=${TARGET}-gcc \
	    AS=${TARGET}-as \
	    AR=${TARGET}-ar \
	    STRIP=${TARGET}-strip \
	    RANLIB=${TARGET}-ranlib \
	    CFLAGS="" \
	    TLSFLAGS="" \
	    all
        ARGS="DESTDIR=${ROOTFS}"
        if [ "$SUFFIX" = "64" ]
        then
            ARGS="$ARGS LIBDIR=${ROOTFS}/usr/lib64 SHLIBDIR=${ROOTFS}/usr/lib64"
        fi
	make $J $ARGS install
	;;

    pcre )
	srpm pcre
	mcd $BUILDDIR/t-pcre
	$SRC/pcre-*/configure $TCONFIGARGS
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	fix_la pcre
	;;

    # TLSFLAGS are set in order to avoid a bogus check in
    # libselinux/src/Makefile.
    libselinux )
	srpm libselinux
	mcd $BUILDDIR/t-libselinux
	rsync -av $SRC/libselinux*/ ./
	# libselinux uses $prefix/include for both -I and *.pc, which
	# prevents cross compiling.
	sed 's@-I$(INCLUDEDIR)@@' < src/Makefile > src/Makefile.stage1
	mv src/Makefile.stage1 src/Makefile
	make $J \
	    CC=${TARGET}-gcc \
	    AS=${TARGET}-as \
	    AR=${TARGET}-ar \
	    STRIP=${TARGET}-strip \
	    RANLIB=${TARGET}-ranlib \
	    CFLAGS="" \
	    TLSFLAGS="" \
	    all
        ARGS="DESTDIR=${ROOTFS}"
        if [ "$SUFFIX" = "64" ]
        then
            ARGS="$ARGS LIBDIR=${ROOTFS}/usr/lib64 SHLIBDIR=${ROOTFS}/usr/lib64"
        fi
	make $J $ARGS install
	;;

#--------------------------------------------------
# target-side applications

    "bash" )
	srpm bash
	mcd $BUILDDIR/bash
	cat <<EOF > config.cache
bash_cv_func_ctype_nonascii=yes
bash_cv_opendir_not_robust=no
bash_cv_ulimit_maxfds=yes
bash_cv_func_sigsetjmp=present
bash_cv_printf_a_format=yes
bash_cv_job_control_missing=present
bash_cv_sys_named_pipes=present
bash_cv_unusable_rtsigs=no
EOF
	$SRC/bash-*/configure --prefix=/ --cache-file=config.cache --build=$BUILD --host=$TARGET
	make $J
	make $J install DESTDIR=${ROOTFS}
	(cd $ROOTFS/bin; ln -sf bash sh)
	;;

    "t-binutils" )
	srpm binutils
	mcd $BUILDDIR/t-binutils
	$SRC/binutils-*/configure $TCONFIGARGS
	notparallel
	make $J
	make $J install DESTDIR=${ROOTFS}
	;;

    "t-gcc" )
	srpm gcc
	mcd $BUILDDIR/t-gcc
	$SRC/gcc-*/configure $GCC_TCONFIGARGS --enable-linker-build-id
	notparallel
	make $J
	make $J install DESTDIR=${ROOTFS}
	test -e ${ROOTFS}/usr/bin/cc && rm ${ROOTFS}/usr/bin/cc
	ln -s gcc ${ROOTFS}/usr/bin/cc
	mkdir -p ${ROOTFS}/usr/share/gdb/auto-load/usr/lib64
	mv -f ${ROOTFS}/usr/lib64/libstdc++*gdb.py* \
	    ${ROOTFS}/usr/share/gdb/auto-load/usr/lib64
	;;

     make | tar | gzip | diffutils | gawk | which | grep )
	srpm $1
	mcd $BUILDDIR/$1
	$SRC/${1}-*/configure $TCONFIGARGS
	notparallel
	test -d tools/gnulib/lib && make $J V=1 -C tools/gnulib/lib
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

     findutils )
	srpm $1
	mcd $BUILDDIR/$1
	sed -i~ -e "s,locate/Makefile locate/testsuite/Makefile ,," $SRC/${1}-*/configure
	FINDLIBS="-lselinux -ldl" $SRC/${1}-*/configure $TCONFIGARGS
	sed -i~ -e "s/ locate / /" Makefile
	notparallel
	test -d tools/gnulib/lib && make $J V=1 -C tools/gnulib/lib
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

     sed )
	srpm $1
	mcd $BUILDDIR/$1
	$SRC/${1}-*/configure $TCONFIGARGS
	notparallel
	# Touch sed.1 so that it will not be built.
	# The makefile in the sed/doc directory attempts to run the
	# built sed binary in order to extract the --help output, but
	# this fails because the sed binary is a cross-tool.
	touch doc/sed.1
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

     patch )
	srpm patch
	mcd $BUILDDIR/$1
	cat <<EOF > config.cache
ac_cv_func_strnlen_working=yes
EOF
	$SRC/${1}-*/configure $TCONFIGARGS --cache-file=config.cache
	notparallel
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

     xz )
	srpm xz
	mcd $BUILDDIR/$1
	$SRC/${1}-*/configure \
	    --prefix=/usr \
            --libdir=/usr/lib64 \
	    --build=$BUILD \
	    --host=$TARGET \
	notparallel
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

     unzip )
	srpm unzip
	mcd $BUILDDIR/$1
	rsync -av $SRC/unzip*/ ./
	make $J -f unix/Makefile \
	    CC=${TARGET}-gcc \
	    AS=${TARGET}-as \
	    AR=${TARGET}-ar \
	    STRIP=${TARGET}-strip \
	    RANLIB=${TARGET}-ranlib \
	    prefix=/usr \
	    generic
	make $J -f unix/Makefile \
	    CC=${TARGET}-gcc \
	    AS=${TARGET}-as \
	    AR=${TARGET}-ar \
	    STRIP=${TARGET}-strip \
	    RANLIB=${TARGET}-ranlib \
	    prefix=${ROOTFS}/usr \
	    install 
	;;

     coreutils )
	srpm coreutils
	mcd $BUILDDIR/$1
	(cd $SRC/${1}-*/ ; autoreconf -vif)
	$SRC/${1}-*/configure $TCONFIGARGS --disable-pam
	notparallel
	make $J man1_MANS= V=1
	make $J man1_MANS= install DESTDIR=${ROOTFS}
	;;

     busybox )
        srpm busybox
        mcd $BUILDDIR/$1
        rsync -av $SRC/busybox-*/ ./
        notparallel
        test -z $BUSYBOX_DEFCONFIG || make $BUSYBOX_DEFCONFIG CROSS_COMPILE=${TARGET}-
        make busybox CROSS_COMPILE=${TARGET}-
        make install CROSS_COMPILE=${TARGET}- CONFIG_PREFIX=${ROOTFS}

        # add a password file for cleaniness (even if it has no passwd)
        (
            echo "root::0:0:root:/:/bin/bash"
        ) > $ROOTFS/etc/passwd
	echo "root:x:0:" > $ROOTFS/etc/group

        # add in some basic mount points
        [ -d ${ROOTFS}/proc ] || mkdir ${ROOTFS}/proc
        [ -d ${ROOTFS}/sys ] || mkdir ${ROOTFS}/sys
	(
	    echo "proc   /proc   proc     defaults        0       0"
	    echo "sysfs  /sys    sysfs    defaults        0       0"
	) > $ROOTFS/etc/fstab
        touch $ROOTFS/etc/mtab

        # and a place holder for other useful initializations
        [ -d ${ROOTFS}/etc/init.d ] || mkdir -p ${ROOTFS}/etc/init.d
	(
	    echo "#!/bin/sh"
	    echo "/bin/mount -a"
	) > $ROOTFS/etc/init.d/rcS
        chmod +x ${ROOTFS}/etc/init.d/rcS
        ;;

     util-linux )
	srpm util-linux
	mcd $BUILDDIR/$1
	cat <<EOF > config.cache
ax_cv_have_tls=yes
scanf_cv_alloc_modifier=ms
EOF
	$SRC/${1}-*/configure $TCONFIGARGS --without-ncurses \
           --prefix=/usr --libexecdir=/usr/lib${SUFFIX} --libdir=/usr/lib${SUFFIX} \
           --disable-wall --cache-file=config.cache
	notparallel
	make $J V=1
	make $J install DESTDIR=${ROOTFS}
	;;

    bzip2 )
	srpm bzip2
	mcd $BUILDDIR/bzip2
	rsync -av $SRC/bzip2-*/ ./
	make $J \
	    CC=${TARGET}-gcc \
	    AR=${TARGET}-ar \
	    RANLIB=${TARGET}-ranlib \
	    PREFIX=/usr \
	    CFLAGS="$CFLAGS -fpic -fPIC" \
	    libbz2.a bzip2 bzip2recover
        if [ "$SUFFIX" = "64" ]
        then
            ARGS="BITS=64"
        fi
	make $J $ARGS \
	    CC=${TARGET}-gcc \
	    AR=${TARGET}-ar \
	    RANLIB=${TARGET}-ranlib \
	    PREFIX=${ROOTFS}/usr \
	    install
	# the installation makes symbols links with our host's paths
	# in them, we need to redo those.
	cd $ROOTFS/usr/bin
	rm bzless;  ln -s bzmore bzless
	rm bzfgrep; ln -s bzgrep bzfgrep
	rm bzcmp;   ln -s bzdiff bzcmp
	rm bzegrep; ln -s bzgrep bzegrep
	;;

    distcc )
	srpm distcc
	mcd $BUILDDIR/distcc
	$SRC/${1}-*/configure $TCONFIGARGS --disable-Werror --without-avahi
	notparallel
	make $J V=1
	make $J install DESTDIR=${ROOTFS}

	mcd $ROOTFS/stage2/distcc-bin
	for p in gcc cc g++ c++ as ${TARGET}-gcc ${TARGET}-g++ ${TARGET}-as
	do
	    test -e $p && rm $p
	    ln -s /usr/bin/distcc $p
	done
	;;

    ccache )
	srpm ccache
	mcd $BUILDDIR/ccache
	$SRC/${1}-*/configure $TCONFIGARGS
	notparallel
	make $J V=1
	make $J install DESTDIR=${ROOTFS}

	mcd $ROOTFS/stage2/ccache-bin
	for p in gcc cc g++ c++ as ${TARGET}-gcc ${TARGET}-g++ ${TARGET}-as
	do
	    test -e $p && rm $p
	    ln -s /usr/bin/ccache $p
	done
	;;

    stage2 )
	# install source trees in rootfs, so stage2 will have them for
	# its builds.

	case "$TARGET" in
	    *i686* )
		if [ ! -f $ROOTFS/usr/bin/uname-bin ]
		then
		    mv $ROOTFS/usr/bin/uname $ROOTFS/usr/bin/uname-bin
		    echo "#!/bin/sh" > $ROOTFS/usr/bin/uname
		    echo '/usr/bin/uname-bin "$@" | sed s/x86_64/i686/g' >> $ROOTFS/usr/bin/uname
		    chmod a+x $ROOTFS/usr/bin/uname
		fi
		;;
	esac

	mkdirp $ROOTFS/stage2/recipe.d

	# FIXME: the recipe files need to be copied into the rootfs
	# before they can be used.

	cp $MYDIR/recipe.d/* $ROOTFS/stage2/recipe.d
	cp $MYDIR/macros.bashrc $ROOTFS/stage2
	cp $MYDIR/script2makefile $ROOTFS/stage2

	for PKG in $ROOTFS/stage2/recipe.d/*
	do
	    case "$PKG" in
		*~ ) ;;
		*# ) ;;
		*/XXXX-* ) ;;
		*)
		PKG=$(echo $PKG | sed "s/.*\\///; s/^[0-9][0-9][0-9][0-9]-//")
		echo "Installing SRPM for $PKG"
		rsrpm $PKG
		;;
	    esac
	done

# Replace all source config.{guess,sub} with more recent versions.
	for i in $(find $ROOTFS/stage2 -name config.guess -o -name config.sub); do
	    [ -f  $TOP/$(basename $i) ] && rm -f $i && cp -fv $TOP/$(basename $i) $i
	done

	(
	    cd $ROOTFS/stage2/rpmbuild/BUILD/sqlite-*
	    test -f sqlite3.h.stage1 \
	    || tclsh tool/mksqlite3h.tcl . > sqlite3.h.stage1
	)

	cp $STAGE2 $ROOTFS/stage2/stage2

	(
            # BOZO: temporary fix for network issues in models
	    #newJ=$(echo $J | sed 's/-j//')
	    #echo J=-j$newJ

	    #echo DISTCC_HOSTS=$(host $(hostname) | sed 's/.* //'):${DISTCC_PORT}/999
            echo J=-j1
            echo DISTCC_HOSTS=localhost
            # END BOZO

	    echo DISTCC_BACKOFF_PERIOD=0
	    echo PATH=/stage2/distcc-bin:\$PATH

	    echo PATH=/stage2/ccache-bin:\$PATH

	    echo TARGET=$TARGET
	    echo RPMTARGET=$RPMTARGET
	    echo TCONFIGARGS=\"$TCONFIGARGS\" \
		| sed 's/--build=[^ ]*//' \
		| sed 's/--host=[^ ]*//' \
		| sed 's/--target=[^ ]*//' \
		| sed 's/--with-sysroot=[^ ]*//' \
		| sed 's/--with-build-sysroot=[^ ]*//' \
		| sed 's/--disable-multilib//' \
		| sed 's/--with-arch=armv8//' \
		| sed 's/--with-fpu=neon-fp-armv8//'
            echo SUFFIX=$SUFFIX

	    echo export J DISTCC_HOSTS DISTCC_BACKOFF_PERIOD PATH
	    echo export TARGET RPMTARGET TCONFIGARGS SUFFIX
	) > $ROOTFS/stage2/local.conf

	mcd $PREFIX/distccd-bin
	rm -f gcc cc g++ c++ as ${TARGET}-gcc ${TARGET}-g++ ${TARGET}-as
	ln -s $PREFIX/bin/${TARGET}-gcc gcc
	ln -s $PREFIX/bin/${TARGET}-gcc cc
	ln -s $PREFIX/bin/${TARGET}-gcc ${TARGET}-gcc
	ln -s $PREFIX/bin/${TARGET}-g++ ${TARGET}-g++
	ln -s $PREFIX/bin/${TARGET}-g++ g++
	ln -s $PREFIX/bin/${TARGET}-g++ c++
	ln -s $PREFIX/bin/${TARGET}-as as
	ln -s $PREFIX/bin/${TARGET}-as ${TARGET}-as
	cd $TOP
	(
	    echo #!/bin/sh
	    echo export PATH=$PREFIX/distccd-bin:\$PATH
	    # The allow means "anyone" since we don't know which host the target is.
	    # add --wizard to shut off background mode and logs info to stdout
	    echo distccd --daemon --allow 0.0.0.0/0 --port $DISTCC_PORT '"$@"'
	) > distccd.script
	chmod a+x distccd.script

        # add in the handy script to make sure the rootfs is usable
        # as an NFS root (and then execute it)
        cp init-rootfs.sh $ROOTFS/
        chmod a+x $ROOTFS/init-rootfs.sh
        ( cd $ROOTFS; sudo ./init-rootfs.sh )

        # make sure ld.so.conf is set up properly
        (
            echo /lib$SUFFIX
            echo /usr/lib$SUFFIX
        ) > $ROOTFS/etc/ld.so.conf

	echo stage2 ready

	;;

    stage3 )
	# This assumes stage2 was run and the files are available

	mkdirp $ROOTFS/stage3/stage3.d

	test -e $ROOTFS/stage3/local.conf && rm $ROOTFS/stage3/local.conf
	cp $ROOTFS/stage2/local.conf $ROOTFS/stage3/local.conf

	cp $MYDIR/stage3.d/* $ROOTFS/stage3/stage3.d
	cp $MYDIR/macros.bashrc $ROOTFS/stage3
	cp $MYDIR/script2makefile $ROOTFS/stage3

	cp $STAGE3 $ROOTFS/stage3/stage3

	test -d $ROOTFS/stage3/done || mkdir $ROOTFS/stage3/done

	echo stage3 ready

	;;

esac

exit 0
